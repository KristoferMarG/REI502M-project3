---
title: "Project 3 - Cluster Analysis"
author: 
  - Jón Þorsteinsson - jth56@hi.is
  - Kristófer Már Gíslason - kmg14@hi.is
output: 
  html_document:
    css: styles.css
    theme: lumen
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cluster)
library(merTools)
library(dendextend)
library(colorspace) # get nice colors
```

### 1. Objectives

Our main obective was to determine with the highest possible accuracy what type of glass is found. Our ideal results would include 7 well defined clusters where each cluster would represent a glass type. The reason this can be found usefull is because of criminological investigations. Where at a scene of a crime glass can be correctly identified and possibly be used as valuable evidence.




### 2. Data set description

Without any preprocessing our data set has 214 different instances that each contain 10 different attributes and one class attribute that tells us what kind of glass it is from the 7 possible options.

| Nr. | Name | Type | Description |
| --- | ---- | ---- | ----------- |
| 1. | Id| numerical | number: 1 to 214 |
| 2. | RI| numerical | Refractive Index |
| 3. | Na| numerical | Sodium |
| 4. | Mg| numerical | Magnesium |
| 5. | Al| numerical | Aluminum |
| 6. | Si| numerical | Silicon |
| 7. | K | numerical | Potassium |
| 8. | Ca| numerical | Calcium|
| 9. | Ba |numerical | Barium |
| 10. |Fe |numerical | Iron| 
| 11. | Class | nominal | class - (building_windows_float_processed,building_windows_non_float_processed,vehicle_windows_float_processed, vehicle_windows_non_float_processed,containers,tableware,headlamps)|

#Preprocessing

We began by looking at all our attributes and noticed that the first one **Id** is completely useless to us because it only numbers the instances which we don't need. We also noticed that the class attributes never results to the glass being *vehicle_windows_non_float_processed* for this dataset so we should get one fewer clusters in the final result. All other attributes seem like they might have some interesting information so we include them. It is also imperative to normalize the scale of feature values in order to begin with the clustering process. This is because each observations' feature values are represented as coordinates in n-dimensional space



```{r data, tidy = TRUE}


# read in data file
glass <- read.csv("glass.csv")

# remove the Id and Class attribute
glass <- glass[2:10]

# normalizing all attributes 
glass <- scale(glass)


```

### 3. K-means clustering

Now that we have finished preprocessing the next step is to run the k-means algorithm but first we need to find what number of clusters that will give us the best result we accomplish this by plotting the sum of squares and seeing when the drop decreases. Since the initial cluster assignments are random, we need to set the seed to ensure reproducibility. 
By plotting the sum of squares we can see that the drop of the y-axis decreases when the number of clusters is 6 this is ideal because the possible types of glass is also 6. 



```{r kmeans}


# Determine number of clusters
wss <- (nrow(glass)-2)*sum(apply(glass,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(glass,centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters", ylab="sum of squares")

# Ensuring reproducibility
set.seed(20)
# running k-means 
glassClusterKmeans <- kmeans(glass, 6, nstart = 20, iter.max=100)


```

 
We used Principal component analysis (PCA) algorithm in **clusplot** to plot and view the clusters after the k-means algorithm. PCA is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables.

```{r hierarchical}


#glass <- scale(glass) # standardize variables
# random subsample from dataset
#randsample <- glass[sample(1:nrow(glass), 20 , replace=FALSE),]


# plotting the clusters
clusplot(glass, glassClusterKmeans$cluster,
         main='Cluster solution',
         color=TRUE, shade=TRUE, labels=2, lines=0)


# reviewing the total sum of squared errors  
glass_kmeans_error <- sum(glassClusterKmeans$withinss)




```

50.68% of variability says that, with our data, more than half of the information about the multivariate data is captured by this plot of components 1 and 2.



### 4. Hierarchical Clustering

Next we use *hclust* to calculate and plot the Hierarchical Clustering with the already preproccessed data. *hclust* requires us to provide the data in the form of a distance matrix. We can do this by using *dist*. By default, the complete linkage method is used.


```{r hiearchy}

fit_2 <- dist(glass, method = 'euclidean')
d <- hclust(fit_2, method = "complete")

# Create a dendrogram object from the hclust variable
dend <- as.dendrogram(d)

# Color brances by cluster formed from the cut at a height of 6
colDat <- color_branches(dend, h = 6)

# Plot the dendrogram 
plot(colDat)


```

The result from this is way too crowded and we can't really see anything so we can cut off the tree at the desired number of clusters using cutree and as shown before we know that the optimal number of clusters is around 6.

```{r hiearchy_2}

# distance matrix
d <- dist(glass, method = "euclidean") 
fit <- hclust(d) 

# display dendogram
plot(fit) 

# cut tree into 6 clusters
groups <- cutree(fit, k=6) 

# draw dendogram with blue borders around the 6 clusters 
rect.hclust(fit, k=6, border="blue")

```


The ouput after cutting the tree is still not very efficient we can't really tell any results from it, so we must..... ** Finna ehv til að laga þetta ! **


```{r continue}




```


### 5. Comparison of K-means and Hierarchical

Before we compare the k-means and Hierarchial clustering we must acknowledge what differences thes two clustering methods have. Both have flaws and strengths such as the Hierarchical clustering can virtually handle any distance metric while k-means relys on euclidean distances. k-means doesn't have the same stability of results as Hierarchial because k-means requires a random step at its initialization that may yield different results if the process is re-run. That wouldn't be the case in hierarchical clustering.
K-means is also less computationally expensive than hierarchical clustering and can be run on large datasets within a reasonable time frame, which is the main reason k-means is more popular. 
The results we got indicated ....... ** samanburður á niðurstöðum hingað ** 










